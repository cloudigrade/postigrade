.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "PGBOUNCER.INI" "5" "" "1.24.1" "Databases"
.hy
.SH NAME
.PP
pgbouncer.ini - configuration file for pgbouncer
.SH DESCRIPTION
.PP
The configuration file is in \[lq]ini\[rq] format.
Section names are between \[lq][\[dq] and \[dq]]\[rq].
Lines starting with \[lq];\[rq] or \[lq]#\[rq] are taken as comments and
ignored.
The characters \[lq];\[rq] and \[lq]#\[rq] are not recognized as special
when they appear later in the line.
.SH GENERIC SETTINGS
.SS logfile
.PP
Specifies the log file.
For daemonization (\f[C]-d\f[R]), either this or \f[C]syslog\f[R] need
to be set.
.PP
The log file is kept open, so after rotation, \f[C]kill -HUP\f[R] or on
console \f[C]RELOAD;\f[R] should be done.
On Windows, the service must be stopped and started.
.PP
Note that setting \f[C]logfile\f[R] does not by itself turn off logging
to stderr.
Use the command-line option \f[C]-q\f[R] or \f[C]-d\f[R] for that.
.PP
Default: not set
.SS pidfile
.PP
Specifies the PID file.
Without \f[C]pidfile\f[R] set, daemonization (\f[C]-d\f[R]) is not
allowed.
.PP
Default: not set
.SS listen_addr
.PP
Specifies a list (comma-separated) of addresses where to listen for TCP
connections.
You may also use \f[C]*\f[R] meaning \[lq]listen on all addresses\[rq].
When not set, only Unix socket connections are accepted.
.PP
Addresses can be specified numerically (IPv4/IPv6) or by name.
.PP
Default: not set
.SS listen_port
.PP
Which port to listen on.
Applies to both TCP and Unix sockets.
.PP
Default: 6432
.SS unix_socket_dir
.PP
Specifies the location for Unix sockets.
Applies to both the listening socket and to server connections.
If set to an empty string, Unix sockets are disabled.
A value that starts with \f[C]\[at]\f[R] specifies that a Unix socket in
the abstract namespace should be created (currently supported on Linux
and Windows).
.PP
For online reboot (\f[C]-R\f[R]) to work, a Unix socket needs to be
configured, and it needs to be in the file-system namespace.
.PP
Default: \f[C]/tmp\f[R] (empty on Windows)
.SS unix_socket_mode
.PP
File system mode for Unix socket.
Ignored for sockets in the abstract namespace.
Not supported on Windows.
.PP
Default: 0777
.SS unix_socket_group
.PP
Group name to use for Unix socket.
Ignored for sockets in the abstract namespace.
Not supported on Windows.
.PP
Default: not set
.SS user
.PP
If set, specifies the Unix user to change to after startup.
Works only if PgBouncer is started as root or if it\[cq]s already
running as the given user.
Not supported on Windows.
.PP
Default: not set
.SS pool_mode
.PP
Specifies when a server connection can be reused by other clients.
.TP
session
Server is released back to pool after client disconnects.
Default.
.TP
transaction
Server is released back to pool after transaction finishes.
.TP
statement
Server is released back to pool after query finishes.
Transactions spanning multiple statements are disallowed in this mode.
.SS max_client_conn
.PP
Maximum number of client connections allowed.
.PP
When this setting is increased, then the file descriptor limits in the
operating system might also have to be increased.
Note that the number of file descriptors potentially used is more than
\f[C]max_client_conn\f[R].
If each user connects under its own user name to the server, the
theoretical maximum used is:
.IP
.nf
\f[C]
max_client_conn + (max pool_size * total databases * total users)
\f[R]
.fi
.PP
If a database user is specified in the connection string (all users
connect under the same user name), the theoretical maximum is:
.IP
.nf
\f[C]
max_client_conn + (max pool_size * total databases)
\f[R]
.fi
.PP
The theoretical maximum should never be reached, unless somebody
deliberately crafts a special load for it.
Still, it means you should set the number of file descriptors to a
safely high number.
.PP
Search for \f[C]ulimit\f[R] in your favorite shell man page.
Note: \f[C]ulimit\f[R] does not apply in a Windows environment.
.PP
Default: 100
.SS default_pool_size
.PP
How many server connections to allow per user/database pair.
Can be overridden in the per-database configuration.
.PP
Default: 20
.SS min_pool_size
.PP
Add more server connections to pool if below this number.
Improves behavior when the normal load suddenly comes back after a
period of total inactivity.
The value is effectively capped at the pool size.
.PP
Only enforced for pools where at least one of the following is true:
.IP \[bu] 2
the entry in the \f[C][database]\f[R] section for the pool has a value
set for the \f[C]user\f[R] key (aka forced user)
.IP \[bu] 2
there is at least one client connected to the pool
.PP
Default: 0 (disabled)
.SS reserve_pool_size
.PP
How many additional connections to allow to a pool (see
\f[C]reserve_pool_timeout\f[R]).
0 disables.
.PP
Default: 0 (disabled)
.SS reserve_pool_timeout
.PP
If a client has not been serviced in this time, use additional
connections from the reserve pool.
0 disables.
[seconds]
.PP
Default: 5.0
.SS max_db_connections
.PP
Do not allow more than this many server connections per database
(regardless of user).
This considers the PgBouncer database that the client has connected to,
not the PostgreSQL database of the outgoing connection.
.PP
This can also be set per database in the \f[C][databases]\f[R] section.
.PP
Note that when you hit the limit, closing a client connection to one
pool will not immediately allow a server connection to be established
for another pool, because the server connection for the first pool is
still open.
Once the server connection closes (due to idle timeout), a new server
connection will immediately be opened for the waiting pool.
.PP
Default: 0 (unlimited)
.SS max_db_client_connections
.PP
Do not allow more than this many client connections to PgBouncer per
database (regardless of user).
This considers the PgBouncer database that the client has connected to,
not the PostgreSQL database of the outgoing connection.
.PP
This should be set at a number greater than or equal to
max_db_connections.
The difference between the two numbers can be thought of as how many
connections to a given database can be in the queue while waiting for
active connections to finish.
.PP
This can also be set per database in the \f[C][databases]\f[R] section.
.PP
Default: 0 (unlimited)
.SS max_user_connections
.PP
Do not allow more than this many server connections per user (regardless
of database).
This considers the PgBouncer user that is associated with a pool, which
is either the user specified for the server connection or in absence of
that the user the client has connected as.
.PP
This can also be set per user in the \f[C][users]\f[R] section.
.PP
Note that when you hit the limit, closing a client connection to one
pool will not immediately allow a server connection to be established
for another pool, because the server connection for the first pool is
still open.
Once the server connection closes (due to idle timeout), a new server
connection will immediately be opened for the waiting pool.
.PP
Default: 0 (unlimited)
.SS max_user_client_connections
.PP
Do not allow more than this many client connections per user (regardless
of database).
This value should be set to a number higher than max_user_connections.
This difference between max_user_connections and
max_user_client_connections can be conceptualized as the number the max
size of the queue for the user.
.PP
This can also be set per user in the \f[C][users]\f[R] section.
.PP
Default: 0 (unlimited)
.SS server_round_robin
.PP
By default, PgBouncer reuses server connections in LIFO (last-in,
first-out) manner, so that few connections get the most load.
This gives best performance if you have a single server serving a
database.
But if there is a round-robin system behind a database address (TCP,
DNS, or host list), then it is better if PgBouncer also uses connections
in that manner, thus achieving uniform load.
.PP
Default: 0
.SS track_extra_parameters
.PP
By default, PgBouncer tracks \f[C]client_encoding\f[R],
\f[C]datestyle\f[R], \f[C]timezone\f[R],
\f[C]standard_conforming_strings\f[R] and \f[C]application_name\f[R]
parameters per client.
To allow other parameters to be tracked, they can be specified here, so
that PgBouncer knows that they should be maintained in the client
variable cache and restored in the server whenever the client becomes
active.
.PP
If you need to specify multiple values, use a comma-separated list (e.g.
\f[C]default_transaction_read_only, IntervalStyle\f[R])
.PP
Note: Most parameters cannot be tracked this way.
The only parameters that can be tracked are ones that Postgres reports
to the client.
Postgres has an official list of parameters that it reports to the
client (https://www.postgresql.org/docs/15/protocol-flow.html#PROTOCOL-ASYNC).
Postgres extensions can change this list though, they can add parameters
themselves that they also report, and they can start reporting already
existing parameters that Postgres does not report.
Notably Citus 12.0+ causes Postgres to also report
\f[C]search_path\f[R].
.PP
The Postgres protocol allows specifying parameters settings, both
directly as a parameter in the startup packet, or inside the
\f[C]options\f[R] startup
packet (https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNECT-OPTIONS).
Parameters specified using both of these methods are supported by
\f[C]track_extra_parameters\f[R].
However, it\[cq]s not possible to include \f[C]options\f[R] itself in
\f[C]track_extra_parameters\f[R], only the parameters contained in
\f[C]options\f[R].
.PP
Default: IntervalStyle
.SS ignore_startup_parameters
.PP
By default, PgBouncer allows only parameters it can keep track of in
startup packets: \f[C]client_encoding\f[R], \f[C]datestyle\f[R],
\f[C]timezone\f[R] and \f[C]standard_conforming_strings\f[R].
All others parameters will raise an error.
To allow others parameters, they can be specified here, so that
PgBouncer knows that they are handled by the admin and it can ignore
them.
.PP
If you need to specify multiple values, use a comma-separated list (e.g.
\f[C]options,extra_float_digits\f[R])
.PP
The Postgres protocol allows specifying parameters settings, both
directly as a parameter in the startup packet, or inside the
\f[C]options\f[R] startup
packet (https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNECT-OPTIONS).
Parameters specified using both of these methods are supported by
\f[C]ignore_startup_parameters\f[R].
It\[cq]s even possible to include \f[C]options\f[R] itself in
\f[C]track_extra_parameters\f[R], which results in any unknown
parameters contained inside \f[C]options\f[R] to be ignored.
.PP
Default: empty
.SS peer_id
.PP
The peer id used to identify this PgBouncer process in a group of
PgBouncer processes that are peered together.
The \f[C]peer_id\f[R] value should be unique within a group of peered
PgBouncer processes.
When set to 0 pgbouncer peering is disabled.
See the docs for the \f[C][peers]\f[R] section for more information.
The maximum value that can be used for the \f[C]peer_id\f[R] is 16383.
.PP
Default: 0
.SS disable_pqexec
.PP
Disable the Simple Query protocol (PQexec).
Unlike the Extended Query protocol, Simple Query allows multiple queries
in one packet, which allows some classes of SQL-injection attacks.
Disabling it can improve security.
Obviously, this means only clients that exclusively use the Extended
Query protocol will stay working.
.PP
Default: 0
.SS application_name_add_host
.PP
Add the client host address and port to the application name setting set
on connection start.
This helps in identifying the source of bad queries etc.
This logic applies only at the start of a connection.
If \f[C]application_name\f[R] is later changed with \f[C]SET\f[R],
PgBouncer does not change it again.
.PP
Default: 0
.SS conffile
.PP
Show location of current config file.
Changing it will make PgBouncer use another config file for next
\f[C]RELOAD\f[R] / \f[C]SIGHUP\f[R].
.PP
Default: file from command line
.SS service_name
.PP
Used on win32 service registration.
.PP
Default: \f[C]pgbouncer\f[R]
.SS job_name
.PP
Alias for \f[C]service_name\f[R].
.SS stats_period
.PP
Sets how often the averages shown in various \f[C]SHOW\f[R] commands are
updated and how often aggregated statistics are written to the log (but
see \f[C]log_stats\f[R]).
[seconds]
.PP
Default: 60
.SS max_prepared_statements
.PP
When this is set to a non-zero value PgBouncer tracks protocol-level
named prepared statements related commands sent by the client in
transaction and statement pooling mode.
PgBouncer makes sure that any statement prepared by a client is
available on the backing server connection.
Even when the statement was originally prepared on another server
connection.
.PP
PgBouncer internally examines all the queries that are sent by clients
as a prepared statement, and gives each unique query string an internal
name with the format \f[C]PGBOUNCER_{unique_id}\f[R].
If the same query string is prepared multiple times (possibly by
different clients), then these queries share the same internal name.
PgBouncer only prepares the statement on the actual PostgreSQL server
using the internal name (so not the name provided by the client).
PgBouncer keeps track of the name that the client gave to each prepared
statement.
It then rewrites each command that uses a prepared statement to by
replacing the client side name with the the internal name (e.g.
replacing \f[C]my_prepared_statement\f[R] with \f[C]PGBOUNCER_123\f[R])
before forwarding that command to the server.
More importantly, if the prepared statement that the client wants to
execute is not yet prepared on the server (e.g.\ because a different
server is now assigned to the client than when the client prepared the
statement), then PgBouncer transparently prepares the statement before
executing it.
.PP
Note: This tracking and rewriting of prepared statement commands does
not work for SQL-level prepared statement commands, so
\f[C]PREPARE\f[R], \f[C]EXECUTE\f[R] and \f[C]DEALLOCATE\f[R] are
forwarded straight to Postgres.
The exception to this rule are the \f[C]DEALLOCATE ALL\f[R] and
\f[C]DISCARD ALL\f[R] commands, these do work as expected and will clear
the prepared statements that PgBouncer tracked for the client that sends
this command.
.PP
The actual value of this setting controls the number of prepared
statements kept active in an LRU cache on a single server connection.
When the setting is set to 0 prepared statement support for transaction
and statement pooling is disabled.
To get the best performance you should try to make sure that this
setting is larger than the amount of commonly used prepared statements
in your application.
Keep in mind that the higher this value, the larger the memory footprint
of each PgBouncer connection will be on your PostgreSQL server, because
it will keep more queries prepared on those connections.
It also increases the memory footprint of PgBouncer itself, because it
now needs to keep track of query strings.
.PP
The impact on PgBouncer memory usage is not that big though: - Each
unique query is stored once in a global query cache.
- Each client connection keeps a buffer that it uses to rewrite packets.
This is, at most, 4 times the size of \f[C]pkt_buf\f[R].
This limit is often not reached though, it only happens when the queries
in your prepared statements are between 2 and 4 times the size of
\f[C]pkt_buf\f[R].
.PP
So if you consider the following as an example scenario: - There are
1000 active clients - The clients prepare 200 unique queries - The
average size of a query is 5kB - \f[C]pkt_buf\f[R] parameter is set to
the default of 4096 (4kB)
.PP
Then, PgBouncer needs at most the following amount of memory to handle
these prepared statements:
.PP
200 x 5kB + 1000 x 4 x 4kB = \[ti]17MB of memory.
.PP
Tracking prepared statements does not only come with a memory cost, but
also with increased CPU usage, because PgBouncer needs to inspect and
rewrite the queries.
Multiple PgBouncer instances can listen on the same port to use more
than one core for processing, see the documentation for the
\f[C]so_reuseport\f[R] option for details.
.PP
But of course there are also performance benefits to prepared
statements.
Just as when connecting to PostgreSQL directly, by preparing a query
that is executed many times, it reduces the total amount of parsing and
planning that needs to be done.
The way that PgBouncer tracks prepared statements is especially
beneficial to performance when multiple clients prepare the same
queries.
Because client connections automatically reuse a prepared statement on a
server connection, even if it was prepared by another client.
As an example, if you have a \f[C]pool_size\f[R] of 20 and you have 100
clients that all prepare the exact same query, then the query is
prepared (and thus parsed) only 20 times on the PostgreSQL server.
.PP
The reuse of prepared statements has one downside.
If the return or argument types of a prepared statement changes across
executions then PostgreSQL currently throws an error such as:
.IP
.nf
\f[C]
ERROR:  cached plan must not change result type
\f[R]
.fi
.PP
You can avoid such errors by not having multiple clients that use the
exact same query string in a prepared statement, but expecting different
argument or result types.
One of the most common ways of running into this issue is during a DDL
migration where you add a new column or change a column type on an
existing table.
In those cases you can run \f[C]RECONNECT\f[R] on the PgBouncer admin
console after doing the migration to force a re-prepare of the query and
make the error go away.
.PP
Default: 200
.SH AUTHENTICATION SETTINGS
.PP
PgBouncer handles its own client authentication and has its own database
of users.
These settings control this.
.SS auth_type
.PP
How to authenticate users.
.TP
cert
Client must connect over TLS connection with a valid client certificate.
The user name is then taken from the CommonName field from the
certificate.
.TP
md5
Use MD5-based password check.
This is the default authentication method.
\f[C]auth_file\f[R] may contain both MD5-encrypted and plain-text
passwords.
If \f[C]md5\f[R] is configured and a user has a SCRAM secret, then SCRAM
authentication is used automatically instead.
.TP
scram-sha-256
Use password check with SCRAM-SHA-256.
\f[C]auth_file\f[R] has to contain SCRAM secrets or plain-text
passwords.
.TP
plain
The clear-text password is sent over the wire.
Deprecated.
.TP
trust
No authentication is done.
The user name must still exist in \f[C]auth_file\f[R].
.TP
any
Like the \f[C]trust\f[R] method, but the user name given is ignored.
Requires that all databases are configured to log in as a specific user.
Additionally, the console database allows any user to log in as admin.
.TP
hba
The actual authentication type is loaded from \f[C]auth_hba_file\f[R].
This allows different authentication methods for different access paths,
for example: connections over Unix socket use the \f[C]peer\f[R] auth
method, connections over TCP must use TLS.
.TP
pam
PAM is used to authenticate users, \f[C]auth_file\f[R] is ignored.
This method is not compatible with databases using the
\f[C]auth_user\f[R] option.
The service name reported to PAM is \[lq]pgbouncer\[rq].
\f[C]pam\f[R] is not supported in the HBA configuration file.
.SS auth_hba_file
.PP
HBA configuration file to use when \f[C]auth_type\f[R] is \f[C]hba\f[R].
See section HBA file format below about details.
.PP
Default: not set
.SS auth_ident_file
.PP
Identity map file to use when \f[C]auth_type\f[R] is \f[C]hba\f[R] and a
user map will be defined.
See section Ident map file format below about details.
.PP
Default: not set
.SS auth_file
.PP
The name of the file to load user names and passwords from.
See section Authentication file format below about details.
.PP
Most authentication types (see above) require that either
\f[C]auth_file\f[R] or \f[C]auth_user\f[R] be set; otherwise there would
be no users defined.
.PP
Default: not set
.SS auth_user
.PP
If \f[C]auth_user\f[R] is set, then any user not specified in
\f[C]auth_file\f[R] will be queried through the \f[C]auth_query\f[R]
query from \f[C]pg_authid\f[R] in the database, using
\f[C]auth_user\f[R].
The password of \f[C]auth_user\f[R] will be taken from
\f[C]auth_file\f[R].
(If the \f[C]auth_user\f[R] does not require a password then it does not
need to be defined in \f[C]auth_file\f[R].)
.PP
Direct access to \f[C]pg_authid\f[R] requires admin rights.
It\[cq]s preferable to use a non-superuser that calls a SECURITY DEFINER
function instead.
.PP
Default: not set
.SS auth_query
.PP
Query to load user\[cq]s password from database.
.PP
Direct access to \f[C]pg_authid\f[R] requires admin rights.
It\[cq]s preferable to use a non-superuser that calls a SECURITY DEFINER
function instead.
.PP
Note that the query is run inside the target database.
So if a function is used, it needs to be installed into each database.
.PP
Default:
\f[C]SELECT rolname, CASE WHEN rolvaliduntil < now() THEN NULL ELSE rolpassword END FROM pg_authid WHERE rolname=$1 AND rolcanlogin\f[R]
.SS auth_dbname
.PP
Database name in the \f[C][database]\f[R] section to be used for
authentication purposes.
This option can be either global or overridden in the connection string
if this parameter is specified.
.SH LOG SETTINGS
.SS syslog
.PP
Toggles syslog on/off.
On Windows, the event log is used instead.
.PP
Default: 0
.SS syslog_ident
.PP
Under what name to send logs to syslog.
.PP
Default: \f[C]pgbouncer\f[R] (program name)
.SS syslog_facility
.PP
Under what facility to send logs to syslog.
Possibilities: \f[C]auth\f[R], \f[C]authpriv\f[R], \f[C]daemon\f[R],
\f[C]user\f[R], \f[C]local0-7\f[R].
.PP
Default: \f[C]daemon\f[R]
.SS log_connections
.PP
Log successful logins.
.PP
Default: 1
.SS log_disconnections
.PP
Log disconnections with reasons.
.PP
Default: 1
.SS log_pooler_errors
.PP
Log error messages the pooler sends to clients.
.PP
Default: 1
.SS log_stats
.PP
Write aggregated statistics into the log, every \f[C]stats_period\f[R].
This can be disabled if external monitoring tools are used to grab the
same data from \f[C]SHOW\f[R] commands.
.PP
Default: 1
.SS verbose
.PP
Increase verbosity.
Mirrors the \[lq]-v\[rq] switch on the command line.
For example, using \[lq]-v -v\[rq] on the command line is the same as
\f[C]verbose=2\f[R].
3 is the highest currently-supported verbosity.
.PP
Default: 0
.SH CONSOLE ACCESS CONTROL
.SS admin_users
.PP
Comma-separated list of database users that are allowed to connect and
run all commands on the console.
Ignored when \f[C]auth_type\f[R] is \f[C]any\f[R], in which case any
user name is allowed in as admin.
.PP
Default: empty
.SS stats_users
.PP
Comma-separated list of database users that are allowed to connect and
run read-only queries on the console.
That means all \f[C]SHOW\f[R] commands except \f[C]SHOW FDS\f[R].
.PP
Default: empty
.SH CONNECTION SANITY CHECKS, TIMEOUTS
.SS server_reset_query
.PP
Query sent to server on connection release, before making it available
to other clients.
At that moment no transaction is in progress, so the value should not
include \f[C]ABORT\f[R] or \f[C]ROLLBACK\f[R].
.PP
The query is supposed to clean any changes made to the database session
so that the next client gets the connection in a well-defined state.
The default is \f[C]DISCARD ALL\f[R], which cleans everything, but that
leaves the next client no pre-cached state.
It can be made lighter, e.g.\ \f[C]DEALLOCATE ALL\f[R] to just drop
prepared statements, if the application does not break when some state
is kept around.
.PP
When transaction pooling is used, the \f[C]server_reset_query\f[R] is
not used, because in that mode, clients must not use any session-based
features, since each transaction ends up in a different connection and
thus gets a different session state.
.PP
Default: \f[C]DISCARD ALL\f[R]
.SS server_reset_query_always
.PP
Whether \f[C]server_reset_query\f[R] should be run in all pooling modes.
When this setting is off (default), the \f[C]server_reset_query\f[R]
will be run only in pools that are in sessions-pooling mode.
Connections in transaction-pooling mode should not have any need for a
reset query.
.PP
This setting is for working around broken setups that run applications
that use session features over a transaction-pooled PgBouncer.
It changes non-deterministic breakage to deterministic breakage: Clients
always lose their state after each transaction.
.PP
Default: 0
.SS server_check_delay
.PP
How long to keep released connections available for immediate re-use,
without running \f[C]server_check_query\f[R] on it.
If 0 then the check is always run.
.PP
Default: 30.0
.SS server_check_query
.PP
Simple do-nothing query to check if the server connection is alive.
.PP
If an empty string, then sanity checking is disabled.
.PP
Default: \f[C]select 1\f[R]
.SS server_fast_close
.PP
Disconnect a server in session pooling mode immediately or after the end
of the current transaction if it is in \[lq]close_needed\[rq] mode (set
by \f[C]RECONNECT\f[R], \f[C]RELOAD\f[R] that changes connection
settings, or DNS change), rather than waiting for the session end.
In statement or transaction pooling mode, this has no effect since that
is the default behavior there.
.PP
If because of this setting a server connection is closed before the end
of the client session, the client connection is also closed.
This ensures that the client notices that the session has been
interrupted.
.PP
This setting makes connection configuration changes take effect sooner
if session pooling and long-running sessions are used.
The downside is that client sessions are liable to be interrupted by a
configuration change, so client applications will need logic to
reconnect and reestablish session state.
But note that no transactions will be lost, because running transactions
are not interrupted, only idle sessions.
.PP
Default: 0
.SS server_lifetime
.PP
The pooler will close an unused (not currently linked to any client
connection) server connection that has been connected longer than this.
Setting it to 0 means the connection is to be used only once, then
closed.
[seconds]
.PP
This can also be set per database in the \f[C][databases]\f[R] section.
.PP
Default: 3600.0
.SS server_idle_timeout
.PP
If a server connection has been idle more than this many seconds it will
be closed.
If 0 then this timeout is disabled.
[seconds]
.PP
Default: 600.0
.SS server_connect_timeout
.PP
If connection and login don\[cq]t finish in this amount of time, the
connection will be closed.
[seconds]
.PP
Default: 15.0
.SS server_login_retry
.PP
If login to the server failed, because of failure to connect or from
authentication, the pooler waits this much before retrying to connect.
During the waiting interval, new clients trying to connect to the
failing server will get an error immediately without another connection
attempt.
[seconds]
.PP
The purpose of this behavior is that clients don\[cq]t unnecessarily
queue up waiting for a server connection to become available if the
server is not working.
However, it also means that if a server is momentarily failing, for
example during a restart or if the configuration was erroneous, then it
will take at least this long until the pooler will consider connecting
to it again.
Planned events such as restarts should normally be managed using the
\f[C]PAUSE\f[R] command to avoid this.
.PP
Default: 15.0
.SS client_login_timeout
.PP
If a client connects but does not manage to log in in this amount of
time, it will be disconnected.
Mainly needed to avoid dead connections stalling \f[C]SUSPEND\f[R] and
thus online restart.
[seconds]
.PP
Default: 60.0
.SS autodb_idle_timeout
.PP
If the automatically created (via \[dq]*\[dq]) database pools have been
unused this many seconds, they are freed.
The negative aspect of that is that their statistics are also forgotten.
[seconds]
.PP
Default: 3600.0
.SS dns_max_ttl
.PP
How long DNS lookups can be cached.
The actual DNS TTL is ignored.
[seconds]
.PP
Default: 15.0
.SS dns_nxdomain_ttl
.PP
How long DNS errors and NXDOMAIN DNS lookups can be cached.
[seconds]
.PP
Default: 15.0
.SS dns_zone_check_period
.PP
Period to check if a zone serial has changed.
.PP
PgBouncer can collect DNS zones from host names (everything after first
dot) and then periodically check if the zone serial changes.
If it notices changes, all host names under that zone are looked up
again.
If any host IP changes, its connections are invalidated.
.PP
Works only with c-ares backend (\f[C]configure\f[R] option
\f[C]--with-cares\f[R]).
.PP
Default: 0.0 (disabled)
.SS resolv_conf
.PP
The location of a custom \f[C]resolv.conf\f[R] file.
This is to allow specifying custom DNS servers and perhaps other name
resolution options, independent of the global operating system
configuration.
.PP
Requires evdns (>= 2.0.3) or c-ares (>= 1.15.0) backend.
.PP
The parsing of the file is done by the DNS backend library, not
PgBouncer, so see the library\[cq]s documentation for details on allowed
syntax and directives.
.PP
Default: empty (use operating system defaults)
.SH TLS SETTINGS
.PP
If the contents of any of the cert or key files are changed without
changing the actual setting filename in the config, the new file
contents will be used for new connections after a RELOAD.
Existing connections won\[cq]t be closed though.
If it\[cq]s necessary for security reasons that all connections start
using the new files ASAP, it\[cq]s advised to run RECONNECT after the
RELOAD.
.PP
Changing any TLS settings will trigger a RECONNECT automatically for
security reasons.
.SS client_tls_sslmode
.PP
TLS mode to use for connections from clients.
TLS connections are disabled by default.
When enabled, \f[C]client_tls_key_file\f[R] and
\f[C]client_tls_cert_file\f[R] must be also configured to set up the key
and certificate PgBouncer uses to accept client connections.
The most common certificate file format usable by PgBouncer is pem.
.TP
disable
Plain TCP.
If client requests TLS, it\[cq]s ignored.
Default.
.TP
allow
If client requests TLS, it is used.
If not, plain TCP is used.
If the client presents a client certificate, it is not validated.
.TP
prefer
Same as \f[C]allow\f[R].
.TP
require
Client must use TLS.
If not, the client connection is rejected.
If the client presents a client certificate, it is not validated.
.TP
verify-ca
Client must use TLS with valid client certificate.
.TP
verify-full
Same as \f[C]verify-ca\f[R].
.SS client_tls_key_file
.PP
Private key for PgBouncer to accept client connections.
.PP
Default: not set
.SS client_tls_cert_file
.PP
Certificate for private key.
Clients can validate it.
.PP
Default: not set
.SS client_tls_ca_file
.PP
Root certificate file to validate client certificates.
.PP
Default: not set
.SS client_tls_protocols
.PP
Which TLS protocol versions are allowed.
Allowed values: \f[C]tlsv1.0\f[R], \f[C]tlsv1.1\f[R], \f[C]tlsv1.2\f[R],
\f[C]tlsv1.3\f[R].
Shortcuts: \f[C]all\f[R] (tlsv1.0,tlsv1.1,tlsv1.2,tlsv1.3),
\f[C]secure\f[R] (tlsv1.2,tlsv1.3).
.PP
Default: \f[C]secure\f[R]
.SS client_tls_ciphers
.PP
Allowed TLS ciphers, in OpenSSL syntax.
Shortcuts:
.IP \[bu] 2
\f[C]default\f[R]/\f[C]secure\f[R]/\f[C]fast\f[R]/\f[C]normal\f[R]
(these all use system wide OpenSSL defaults)
.IP \[bu] 2
\f[C]all\f[R] (enables all ciphers, not recommended)
.PP
Only connections using TLS version 1.2 and lower are affected.
There is currently no setting that controls the cipher choices used by
TLS version 1.3 connections.
.PP
Default: \f[C]default\f[R]
.SS client_tls_ecdhcurve
.PP
Elliptic Curve name to use for ECDH key exchanges.
.PP
Allowed values: \f[C]none\f[R] (DH is disabled), \f[C]auto\f[R] (256-bit
ECDH), curve name
.PP
Default: \f[C]auto\f[R]
.SS client_tls_dheparams
.PP
DHE key exchange type.
.PP
Allowed values: \f[C]none\f[R] (DH is disabled), \f[C]auto\f[R]
(2048-bit DH), \f[C]legacy\f[R] (1024-bit DH)
.PP
Default: \f[C]auto\f[R]
.SS server_tls_sslmode
.PP
TLS mode to use for connections to PostgreSQL servers.
The default mode is \f[C]prefer\f[R].
.TP
disable
Plain TCP.
TLS is not even requested from the server.
.TP
allow
FIXME: if server rejects plain, try TLS?
.TP
prefer
TLS connection is always requested first from PostgreSQL.
If refused, the connection will be established over plain TCP.
Server certificate is not validated.
Default
.TP
require
Connection must go over TLS.
If server rejects it, plain TCP is not attempted.
Server certificate is not validated.
.TP
verify-ca
Connection must go over TLS and server certificate must be valid
according to \f[C]server_tls_ca_file\f[R].
Server host name is not checked against certificate.
.TP
verify-full
Connection must go over TLS and server certificate must be valid
according to \f[C]server_tls_ca_file\f[R].
Server host name must match certificate information.
.SS server_tls_ca_file
.PP
Root certificate file to validate PostgreSQL server certificates.
.PP
Default: not set
.SS server_tls_key_file
.PP
Private key for PgBouncer to authenticate against PostgreSQL server.
.PP
Default: not set
.SS server_tls_cert_file
.PP
Certificate for private key.
PostgreSQL server can validate it.
.PP
Default: not set
.SS server_tls_protocols
.PP
Which TLS protocol versions are allowed.
Allowed values: \f[C]tlsv1.0\f[R], \f[C]tlsv1.1\f[R], \f[C]tlsv1.2\f[R],
\f[C]tlsv1.3\f[R].
Shortcuts: \f[C]all\f[R] (tlsv1.0,tlsv1.1,tlsv1.2,tlsv1.3),
\f[C]secure\f[R] (tlsv1.2,tlsv1.3), \f[C]legacy\f[R] (all).
.PP
Default: \f[C]secure\f[R]
.SS server_tls_ciphers
.PP
Allowed TLS ciphers, in OpenSSL syntax.
Shortcuts:
.IP \[bu] 2
\f[C]default\f[R]/\f[C]secure\f[R]/\f[C]fast\f[R]/\f[C]normal\f[R]
(these all use system wide OpenSSL defaults)
.IP \[bu] 2
\f[C]all\f[R] (enables all ciphers, not recommended)
.PP
Only connections using TLS version 1.2 and lower are affected.
There is currently no setting that controls the cipher choices used by
TLS version 1.3 connections.
.PP
Default: \f[C]default\f[R]
.SH DANGEROUS TIMEOUTS
.PP
Setting the following timeouts can cause unexpected errors.
.SS query_timeout
.PP
Queries running longer than that are canceled.
This should be used only with a slightly smaller server-side
\f[C]statement_timeout\f[R], to apply only for network problems.
[seconds]
.PP
Default: 0.0 (disabled)
.SS query_wait_timeout
.PP
Maximum time queries are allowed to spend waiting for execution.
If the query is not assigned to a server during that time, the client is
disconnected.
0 disables.
If this is disabled, clients will be queued indefinitely.
[seconds]
.PP
This setting is used to prevent unresponsive servers from grabbing up
connections.
It also helps when the server is down or rejects connections for any
reason.
.PP
Default: 120.0
.SS cancel_wait_timeout
.PP
Maximum time cancellation requests are allowed to spend waiting for
execution.
If the cancel request is not assigned to a server during that time, the
client is disconnected.
0 disables.
If this is disabled, cancel requests will be queued indefinitely.
[seconds]
.PP
This setting is used to prevent a client locking up when a cancel cannot
be forwarded due to the server being down.
.PP
Default: 10.0
.SS client_idle_timeout
.PP
Client connections idling longer than this many seconds are closed.
This should be larger than the client-side connection lifetime settings,
and only used for network problems.
[seconds]
.PP
Default: 0.0 (disabled)
.SS idle_transaction_timeout
.PP
If a client has been in \[lq]idle in transaction\[rq] state longer, it
will be disconnected.
[seconds]
.PP
Default: 0.0 (disabled)
.SS suspend_timeout
.PP
How long to wait for buffer flush during \f[C]SUSPEND\f[R] or reboot
(\f[C]-R\f[R]).
A connection is dropped if the flush does not succeed.
[seconds]
.PP
Default: 10
.SH LOW-LEVEL NETWORK SETTINGS
.SS pkt_buf
.PP
Internal buffer size for packets.
Affects size of TCP packets sent and general memory usage.
Actual libpq packets can be larger than this, so no need to set it
large.
.PP
Default: 4096
.SS max_packet_size
.PP
Maximum size for PostgreSQL packets that PgBouncer allows through.
One packet is either one query or one result set row.
The full result set can be larger.
.PP
Default: 2147483647
.SS listen_backlog
.PP
Backlog argument for listen(2).
Determines how many new unanswered connection attempts are kept in the
queue.
When the queue is full, further new connections are dropped.
.PP
Default: 128
.SS sbuf_loopcnt
.PP
How many times to process data on one connection, before proceeding.
Without this limit, one connection with a big result set can stall
PgBouncer for a long time.
One loop processes one \f[C]pkt_buf\f[R] amount of data.
0 means no limit.
.PP
Default: 5
.SS so_reuseport
.PP
Specifies whether to set the socket option \f[C]SO_REUSEPORT\f[R] on TCP
listening sockets.
On some operating systems, this allows running multiple PgBouncer
instances on the same host listening on the same port and having the
kernel distribute the connections automatically.
This option is a way to get PgBouncer to use more CPU cores.
(PgBouncer is single-threaded and uses one CPU core per instance.)
.PP
The behavior in detail depends on the operating system kernel.
As of this writing, this setting has the desired effect on (sufficiently
recent versions of) Linux, DragonFlyBSD, and FreeBSD.
(On FreeBSD, it applies the socket option \f[C]SO_REUSEPORT_LB\f[R]
instead.) Some other operating systems support the socket option but it
won\[cq]t have the desired effect: It will allow multiple processes to
bind to the same port but only one of them will get the connections.
See your operating system\[cq]s setsockopt() documentation for details.
.PP
On systems that don\[cq]t support the socket option at all, turning this
setting on will result in an error.
.PP
Each PgBouncer instance on the same host needs different settings for at
least \f[C]unix_socket_dir\f[R] and \f[C]pidfile\f[R], as well as
\f[C]logfile\f[R] if that is used.
Also note that if you make use of this option, you can no longer connect
to a specific PgBouncer instance via TCP/IP, which might have
implications for monitoring and metrics collection.
.PP
To make sure query cancellations keep working, you should set up
PgBouncer peering between the different PgBouncer processes.
For details look at docs for the \f[C]peer_id\f[R] configuration option
and the \f[C]peers\f[R] configuration section.
There\[cq]s also an example that uses peering and so_reuseport in the
example section of these docs.
.PP
Default: 0
.SS tcp_defer_accept
.PP
Sets the \f[C]TCP_DEFER_ACCEPT\f[R] socket option; see
\f[C]man 7 tcp\f[R] for details.
(This is a Boolean option: 1 means enabled.
The actual value set if enabled is currently hardcoded to 45 seconds.)
.PP
This is currently only supported on Linux.
.PP
Default: 1 on Linux, otherwise 0
.SS tcp_socket_buffer
.PP
Default: not set
.SS tcp_keepalive
.PP
Turns on basic keepalive with OS defaults.
.PP
On Linux, the system defaults are tcp_keepidle=7200, tcp_keepintvl=75,
tcp_keepcnt=9.
They are probably similar on other operating systems.
.PP
Default: 1
.SS tcp_keepcnt
.PP
Default: not set
.SS tcp_keepidle
.PP
Default: not set
.SS tcp_keepintvl
.PP
Default: not set
.SS tcp_user_timeout
.PP
Sets the \f[C]TCP_USER_TIMEOUT\f[R] socket option.
This specifies the maximum amount of time in milliseconds that
transmitted data may remain unacknowledged before the TCP connection is
forcibly closed.
If set to 0, then operating system\[cq]s default is used.
.PP
This is currently only supported on Linux.
.PP
Default: 0
.SH SECTION [DATABASES]
.PP
The section \f[C][databases]\f[R] defines the names of the databases
that clients of PgBouncer can connect to and specifies where those
connections will be routed.
The section contains key=value lines like
.IP
.nf
\f[C]
dbname = connection string
\f[R]
.fi
.PP
where the key will be taken as a database name and the value as a
connection string, consisting of key=value pairs of connection
parameters, described below (similar to libpq, but the actual libpq is
not used and the set of available features is different).
Example:
.IP
.nf
\f[C]
foodb = host=host1.example.com port=5432
bardb = host=localhost dbname=bazdb
\f[R]
.fi
.PP
The database name can contain characters \f[C]_0-9A-Za-z\f[R] without
quoting.
Names that contain other characters need to be quoted with standard SQL
identifier quoting: double quotes, with \[dq]\[dq] for a single instance
of a double quote.
.PP
The database name \[lq]pgbouncer\[rq] is reserved for the admin console
and cannot be used as a key here.
.PP
\[dq]*\[dq] acts as a fallback database: If the exact name does not
exist, its value is taken as connection string for the requested
database.
For example, if there is an entry (and no other overriding entries)
.IP
.nf
\f[C]
* = host=foo
\f[R]
.fi
.PP
then a connection to PgBouncer specifying a database \[lq]bar\[rq] will
effectively behave as if an entry
.IP
.nf
\f[C]
bar = host=foo dbname=bar
\f[R]
.fi
.PP
exists (taking advantage of the default for \f[C]dbname\f[R] being the
client-side database name; see below).
.PP
Such automatically created database entries are cleaned up if they stay
idle longer than the time specified by the \f[C]autodb_idle_timeout\f[R]
parameter.
.SS dbname
.PP
Destination database name.
.PP
Default: same as client-side database name
.SS host
.PP
Host name or IP address to connect to.
Host names are resolved at connection time, the result is cached per
\f[C]dns_max_ttl\f[R] parameter.
When a host name\[cq]s resolution changes, existing server connections
are automatically closed when they are released (according to the
pooling mode), and new server connections immediately use the new
resolution.
If DNS returns several results, they are used in a round-robin manner.
.PP
If the value begins with \f[C]/\f[R], then a Unix socket in the
file-system namespace is used.
If the value begins with \f[C]\[at]\f[R], then a Unix socket in the
abstract namespace is used.
.PP
A comma-separated list of host names or addresses can be specified.
In that case, connections are made in a round-robin manner.
(If a host list contains host names that in turn resolve via DNS to
multiple addresses, the round-robin systems operate independently.
This is an implementation dependency that is subject to change.) Note
that in a list, all hosts must be available at all times: There are no
mechanisms to skip unreachable hosts or to select only available hosts
from a list or similar.
(This is different from what a host list in libpq means.) Also note that
this only affects how the destinations of new connections are chosen.
See also the setting \f[C]server_round_robin\f[R] for how clients are
assigned to already established server connections.
.PP
Examples:
.IP
.nf
\f[C]
host=localhost
host=127.0.0.1
host=2001:0db8:85a3:0000:0000:8a2e:0370:7334
host=/var/run/postgresql
host=192.168.0.1,192.168.0.2,192.168.0.3
\f[R]
.fi
.PP
Default: not set, meaning to use a Unix socket
.SS port
.PP
Default: 5432
.SS user
.PP
If \f[C]user=\f[R] is set, all connections to the destination database
will be done with the specified user, meaning that there will be only
one pool for this database.
.PP
Otherwise, PgBouncer logs into the destination database with the client
user name, meaning that there will be one pool per user.
.SS password
.PP
If no password is specified here, the password from the
\f[C]auth_file\f[R] will be used for the user specified above.
Dynamic forms of password discovery such as \f[C]auth_query\f[R] are not
currently supported.
.SS auth_user
.PP
Override of the global \f[C]auth_user\f[R] setting, if specified.
.SS auth_query
.PP
Override of the global \f[C]auth_query\f[R] setting, if specified.
The entire SQL statement needs to be enclosed in single quotes.
.SS auth_dbname
.PP
Override of the global \f[C]auth_dbname\f[R] setting, if specified.
.SS pool_size
.PP
Set the maximum size of pools for this database.
If not set, the \f[C]default_pool_size\f[R] is used.
.SS min_pool_size
.PP
Set the minimum pool size for this database.
If not set, the global \f[C]min_pool_size\f[R] is used.
.PP
Only enforced if at least one of the following is true:
.IP \[bu] 2
this entry in the \f[C][database]\f[R] section has a value set for the
\f[C]user\f[R] key (aka forced user)
.IP \[bu] 2
there is at least one client connected to the pool
.SS reserve_pool_size
.PP
Set additional connections for this database.
If not set, the global \f[C]reserve_pool_size\f[R] is used.
For backwards compatibilty reasons \f[C]reserve_pool\f[R] is an alias
for this option.
.SS connect_query
.PP
Query to be executed after a connection is established, but before
allowing the connection to be used by any clients.
If the query raises errors, they are logged but ignored otherwise.
.SS pool_mode
.PP
Set the pool mode specific to this database.
If not set, the default \f[C]pool_mode\f[R] is used.
.SS load_balance_hosts
.PP
When a comma-separated list is specified in \f[C]host\f[R],
\f[C]load_balance_hosts\f[R] controls which entry is chosen for a new
connection.
.PP
Note: This setting currently only controls the load balancing behaviour
when providing multiple hosts in the connection string, but not when a
single host its DNS record references multiple IP addresses.
This is a missing feature, so in a future release this setting might
start to to control both methods of load balancing.
.TP
round-robin
A new connection attempt chooses the next host entry in the list.
.TP
disable
A new connection continues using the same host entry until a connection
fails, after which the next host entry is chosen.
.PP
It is recommended to set \f[C]server_login_retry\f[R] lower than the
default to ensure fast retries when multiple hosts are available.
.PP
Default: \f[C]round-robin\f[R]
.SS max_db_connections
.PP
Configure a database-wide maximum of server connections (i.e.\ all pools
within the database will not have more than this many server
connections).
.SS max_db_client_connections
.PP
Configure a database-wide client connection maximum.
Should be used in conjunction with max_client_conn to limit the number
of connections that PgBouncer is allowed to accept.
.SS server_lifetime
.PP
Configure the server_lifetime per database.
If not set the database will fall back to the instance wide configured
value for \f[C]server_lifetime\f[R]
.SS client_encoding
.PP
Ask specific \f[C]client_encoding\f[R] from server.
.SS datestyle
.PP
Ask specific \f[C]datestyle\f[R] from server.
.SS timezone
.PP
Ask specific \f[C]timezone\f[R] from server.
.SH SECTION [USERS]
.PP
This section contains key=value lines like
.IP
.nf
\f[C]
user1 = settings
\f[R]
.fi
.PP
where the key will be taken as a user name and the value as a list of
key=value pairs of configuration settings specific for this user.
Example:
.IP
.nf
\f[C]
user1 = pool_mode=session
\f[R]
.fi
.PP
Only a few settings are available here.
.PP
Note that when \f[C]auth_file\f[R] is configured, if a user is defined
in this section but not listed in \f[C]auth_file\f[R], pgBouncer will
attempt to use \f[C]auth_query\f[R] to find a password for that user if
\f[C]auth_user\f[R] is set.
If \f[C]auth_user\f[R] is not set, pgBouncer will pretend the user
exists and fail to return \[lq]no such user\[rq] messages to the client,
but neither will it accept any provided password.
.SS pool_size
.PP
Set the maximum size of pools for all connections from this user.
If not set, the database or \f[C]default_pool_size\f[R] is used.
.SS reserve_pool_size
.PP
Set the number of additional connections to allow to a pool for this
user.
If not set, the database configuration or the global
\f[C]reserve_pool_size\f[R] is used.
.SS pool_mode
.PP
Set the pool mode to be used for all connections from this user.
If not set, the database or default \f[C]pool_mode\f[R] is used.
.SS max_user_connections
.PP
Configure a maximum for the user of server connections (i.e.\ all pools
with the user will not have more than this many server connections).
.SS query_timeout
.PP
Set the maximum number of seconds that a user query can run for.
If set this timeout overrides the server level query_timeout described
above.
.SS idle_transaction_timeout
.PP
Set the maximum number of seconds that a user can have an idle
transaction open.
If set this timeout overides the server level idle_transaction_timeout
described above.
.SS client_idle_timeout
.PP
Set the maximum amount of time in seconds that a client is allowed to
idly connect to the pgbouncer instance.
If set this timeout overrides the server level client_idle_timeout
described above.
.PP
Please note that this is a potentially dangeous timeout.
.SS max_user_client_connections
.PP
Configure a maximum for the user of client connections.
This is the user equivalent ofthe max_client_conn setting.
.SH SECTION [PEERS]
.PP
The section \f[C][peers]\f[R] defines the peers that PgBouncer can
forward cancellation requests to and where those cancellation requests
will be routed.
.PP
PgBouncer processes can be peered together in a group by defining a
\f[C]peer_id\f[R] value and a \f[C][peers]\f[R] section in the configs
of all the PgBouncer processes.
These PgBouncer processes can then forward cancellations requests to the
process that it originated from.
This is needed to make cancellations work when multiple PgBouncer
processes (possibly on different servers) are behind the same TCP load
balancer.
Cancellation requests are sent over different TCP connections than the
query they are cancelling, so a TCP load balancer might send the
cancellation request connection to a different process than the one that
it was meant for.
By peering them these cancellation requests eventually end up at the
right process.
A more in-depth explanation is provided in this recording of a
conference talk (https://www.youtube.com/watch?v=X-nCHcZ6vQU).
.PP
The section contains key=value lines like
.IP
.nf
\f[C]
peer_id = connection string
\f[R]
.fi
.PP
Where the key will be taken as a \f[C]peer_id\f[R] and the value as a
connection string, consisting of key=value pairs of connection
parameters, described below (similar to libpq, but the actual libpq is
not used and the set of available features is different).
Example:
.IP
.nf
\f[C]
1 = host=host1.example.com
2 = host=/tmp/pgbouncer-2  port=5555
\f[R]
.fi
.PP
Note 1: For peering to work, the \f[C]peer_id\f[R] of each PgBouncer
process in the group must be unique within the peered group.
And the \f[C][peers]\f[R] section should contain entries for each of
those peer ids.
An example can be found in the examples section of these docs.
It \f[B]is\f[R] allowed, but not necessary, for the \f[C][peers]\f[R]
section to contain the \f[C]peer_id\f[R] of the PgBouncer that the
config is for.
Such an entry will be ignored, but it is allowed to config management
easy.
Because it allows using the exact same \f[C][peers]\f[R] section for
multiple configs.
.PP
Note 2: Cross-version peering is supported as long as all peers are on
the same side of the v1.21.0 version boundary.
In v1.21.0 some breaking changes were made in how we encode the
cancellation tokens that made them incompatible with the ones created by
earlier versions.
.SS host
.PP
Host name or IP address to connect to.
Host names are resolved at connection time, the result is cached per
\f[C]dns_max_ttl\f[R] parameter.
If DNS returns several results, they are used in a round-robin manner.
But in general it\[cq]s not recommended to use a hostname that resolves
to multiple IPs, because then the cancel request might still be
forwarded to the wrong node and it would need to be forwarded again
(which is only allowed up to three times).
.PP
If the value begins with \f[C]/\f[R], then a Unix socket in the
file-system namespace is used.
If the value begins with \f[C]\[at]\f[R], then a Unix socket in the
abstract namespace is used.
.PP
Examples:
.IP
.nf
\f[C]
host=localhost
host=127.0.0.1
host=2001:0db8:85a3:0000:0000:8a2e:0370:7334
host=/var/run/pgbouncer-1
\f[R]
.fi
.SS port
.PP
Default: 6432
.SS pool_size
.PP
Set the maximum number of cancel requests that can be in flight to the
peer at the same time.
It\[cq]s quite normal for cancel requests to arrive in bursts, e.g.
when the backing Postgres server slow or down.
So it\[cq]s important for \f[C]pool_size\f[R] to not be so low that it
cannot handle these bursts.
.PP
If not set, the \f[C]default_pool_size\f[R] is used.
.SH INCLUDE DIRECTIVE
.PP
The PgBouncer configuration file can contain include directives, which
specify another configuration file to read and process.
This allows splitting the configuration file into physically separate
parts.
The include directives look like this:
.IP
.nf
\f[C]
%include filename
\f[R]
.fi
.PP
If the file name is not an absolute path, it is taken as relative to the
current working directory.
.SH AUTHENTICATION FILE FORMAT
.PP
This section describes the format of the file specified by the
\f[C]auth_file\f[R] setting.
It is a text file in the following format:
.IP
.nf
\f[C]
\[dq]username1\[dq] \[dq]password\[dq] ...
\[dq]username2\[dq] \[dq]md5abcdef012342345\[dq] ...
\[dq]username2\[dq] \[dq]SCRAM-SHA-256$<iterations>:<salt>$<storedkey>:<serverkey>\[dq]
\f[R]
.fi
.PP
There should be at least 2 fields, surrounded by double quotes.
The first field is the user name and the second is either a plain-text,
a MD5-hashed password, or a SCRAM secret.
PgBouncer ignores the rest of the line.
Double quotes in a field value can be escaped by writing two double
quotes.
.PP
PostgreSQL MD5-hashed password format:
.IP
.nf
\f[C]
\[dq]md5\[dq] + md5(password + username)
\f[R]
.fi
.PP
So user \f[C]admin\f[R] with password \f[C]1234\f[R] will have
MD5-hashed password \f[C]md545f2603610af569b6155c45067268c6b\f[R].
.PP
PostgreSQL SCRAM secret format:
.IP
.nf
\f[C]
SCRAM-SHA-256$<iterations>:<salt>$<storedkey>:<serverkey>
\f[R]
.fi
.PP
See the PostgreSQL documentation and RFC 5803 for details on this.
.PP
The passwords or secrets stored in the authentication file serve two
purposes.
First, they are used to verify the passwords of incoming client
connections, if a password-based authentication method is configured.
Second, they are used as the passwords for outgoing connections to the
backend server, if the backend server requires password-based
authentication (unless the password is specified directly in the
database\[cq]s connection string).
.SS Limitations
.PP
If the password is stored in plain text, it can be used for any
password-based authentication used in the backend server; plain text,
MD5 or SCRAM (see
<https://www.postgresql.org/docs/current/auth-password.html> for
details).
.PP
MD5-hashed passwords can be used if backend server uses MD5
authentication (or specific users have MD5-hashed passwords).
.PP
SCRAM secrets can only be used for logging into a server if the client
authentication also uses SCRAM, the PgBouncer database definition does
not specify a user name, and the SCRAM secrets are identical in
PgBouncer and the PostgreSQL server (same salt and iterations, not
merely the same password).
This is due to an inherent security property of SCRAM: The stored SCRAM
secret cannot by itself be used for deriving login credentials.
.PP
The authentication file can be written by hand, but it\[cq]s also useful
to generate it from some other list of users and passwords.
See \f[C]./etc/mkauth.py\f[R] for a sample script to generate the
authentication file from the \f[C]pg_authid\f[R] system table.
Alternatively, use \f[C]auth_query\f[R] instead of \f[C]auth_file\f[R]
to avoid having to maintain a separate authentication file.
.SS Note on managed servers
.PP
If the backend server is configured to use SCRAM password authentication
PgBouncer cannot successfully authenticate if it does not know either a)
user password in plain text or b) corresponding SCRAM secret.
.PP
Some cloud providers (i.e.\ AWS RDS) prohibit access to PostgreSQL
sensitive system tables for fetching passwords.
Even for the most privileged user (i.e.\ member of rds_superuser) the
\f[C]select * from pg_authid\f[R]; returns the
\f[C]ERROR:  permission denied for table pg_authid.\f[R] That is a known
behaviour
(blog (https://aws.amazon.com/blogs/database/best-practices-for-migrating-postgresql-databases-to-amazon-rds-and-amazon-aurora/)).
.PP
Therefore, fetching an existing SCRAM secret once it has been stored in
a managed server is impossible which makes it hard to configure
PgBouncer to use the same SCRAM secret.
Nevertheless, SCRAM secret can still be configured and used on both
sides using the following trick:
.PP
Generate SCRAM secret for arbitrary password with a tool that is capable
of printing out the secret.
For example \f[C]psql --echo-hidden\f[R] and the command
\f[C]\[rs]password\f[R] prints out the SCRAM secret to the console
before sending it over to the server.
.IP
.nf
\f[C]
$ psql --echo-hidden <connection_string>
postgres=# \[rs]password <role_name>
Enter new password for user \[dq]<role_name>\[dq]:
Enter it again:
********* QUERY **********
ALTER USER <role_name> PASSWORD \[aq]SCRAM-SHA-256$<iterations>:<salt>$<storedkey>:<serverkey>\[aq]
**************************
\f[R]
.fi
.PP
Note down the SCRAM secret from the QUERY and set it in PgBouncer\[cq]s
\f[C]userlist.txt\f[R].
.PP
If you used a tool other than \f[C]psql --echo-hidden\f[R] then you need
to set the SCRAM secret also in the server (you can use
\f[C]alter role <role_name> password \[aq]<scram_secret>\[aq]\f[R] for
that).
.SH HBA FILE FORMAT
.PP
The location of the HBA file is specified by the setting
\f[C]auth_hba_file\f[R].
It is only used if \f[C]auth_type\f[R] is set to \f[C]hba\f[R].
.PP
The file follows the format of the PostgreSQL \f[C]pg_hba.conf\f[R] file
(see <https://www.postgresql.org/docs/current/auth-pg-hba-conf.html>).
.IP \[bu] 2
Supported record types: \f[C]local\f[R], \f[C]host\f[R],
\f[C]hostssl\f[R], \f[C]hostnossl\f[R].
.IP \[bu] 2
Database field: Supports \f[C]all\f[R], \f[C]replication\f[R],
\f[C]sameuser\f[R], \f[C]\[at]file\f[R], multiple names.
Not supported: \f[C]samerole\f[R], \f[C]samegroup\f[R].
.IP \[bu] 2
User name field: Supports \f[C]all\f[R], \f[C]\[at]file\f[R], multiple
names.
Not supported: \f[C]+groupname\f[R].
.IP \[bu] 2
Address field: Supports \f[C]all\f[R], IPv4, IPv6.
Not supported: \f[C]samehost\f[R], \f[C]samenet\f[R], DNS names, domain
prefixes.
.IP \[bu] 2
Auth-method field: Only methods supported by PgBouncer\[cq]s
\f[C]auth_type\f[R] are supported, plus \f[C]peer\f[R] and
\f[C]reject\f[R], but except \f[C]any\f[R] and \f[C]pam\f[R], which only
work globally.
.IP \[bu] 2
User name map (\f[C]map=\f[R]) parameter is supported when
\f[C]auth_type\f[R] is \f[C]cert\f[R] or \f[C]peer\f[R].
.SH IDENT MAP FILE FORMAT
.PP
The location of the ident map file is specified by the setting
\f[C]auth_ident_file\f[R].
It is only loaded if \f[C]auth_type\f[R] is set to \f[C]hba\f[R].
.PP
The file format is a simplified variation of the PostgreSQL ident map
file (see
<https://www.postgresql.org/docs/current/auth-username-maps.html>).
.IP \[bu] 2
Supported lines are only of the form
\f[C]map-name system-username database-username\f[R].
.IP \[bu] 2
There is no support for including file/directory.
.IP \[bu] 2
System-username field: Not supported: regular expressions.
.IP \[bu] 2
Database-username field: Supports \f[C]all\f[R] or a single postgres
user name.
Not supported: \f[C]+groupname\f[R], regular expressions.
.SH EXAMPLES
.PP
Small example configuration:
.IP
.nf
\f[C]
[databases]
template1 = host=localhost dbname=template1 auth_user=someuser

[pgbouncer]
pool_mode = session
listen_port = 6432
listen_addr = localhost
auth_type = md5
auth_file = users.txt
logfile = pgbouncer.log
pidfile = pgbouncer.pid
admin_users = someuser
stats_users = stat_collector
\f[R]
.fi
.PP
Database examples:
.IP
.nf
\f[C]
[databases]

; foodb over Unix socket
foodb =

; redirect bardb to bazdb on localhost
bardb = host=localhost dbname=bazdb

; access to destination database will go with single user
forcedb = host=localhost port=300 user=baz password=foo client_encoding=UNICODE datestyle=ISO
\f[R]
.fi
.PP
Example of a secure function for \f[C]auth_query\f[R]:
.IP
.nf
\f[C]
CREATE OR REPLACE FUNCTION pgbouncer.user_lookup(in i_username text, out uname text, out phash text)
RETURNS record AS $$
BEGIN
    SELECT rolname, CASE WHEN rolvaliduntil < now() THEN NULL ELSE rolpassword END
    FROM pg_authid
    WHERE rolname=i_username AND rolcanlogin
    INTO uname, phash;
    RETURN;
END;
$$ LANGUAGE plpgsql
   SECURITY DEFINER
   -- Set a secure search_path: trusted schema(s), then \[aq]pg_temp\[aq].
   SET search_path = pg_catalog, pg_temp;
REVOKE ALL ON FUNCTION pgbouncer.user_lookup(text) FROM public, pgbouncer;
GRANT EXECUTE ON FUNCTION pgbouncer.user_lookup(text) TO pgbouncer;
\f[R]
.fi
.PP
Example configs for 2 peered PgBouncer processes to create a multi-core
PgBouncer setup using \f[C]so_reuseport\f[R].
The config for the first process:
.IP
.nf
\f[C]
[databases]
postgres = host=localhost dbname=postgres

[peers]
1 = host=/tmp/pgbouncer1
2 = host=/tmp/pgbouncer2

[pgbouncer]
listen_addr=127.0.0.1
auth_file=auth_file.conf
so_reuseport=1
unix_socket_dir=/tmp/pgbouncer1
peer_id=1
\f[R]
.fi
.PP
The config for the second process:
.IP
.nf
\f[C]
[databases]
postgres = host=localhost dbname=postgres

[peers]
1 = host=/tmp/pgbouncer1
2 = host=/tmp/pgbouncer2

[pgbouncer]
listen_addr=127.0.0.1
auth_file=auth_file.conf
so_reuseport=1
; only unix_socket_dir and peer_id are different
unix_socket_dir=/tmp/pgbouncer2
peer_id=2
\f[R]
.fi
.SH SEE ALSO
.PP
pgbouncer(1) - man page for general usage, console commands
.PP
<https://www.pgbouncer.org/>
